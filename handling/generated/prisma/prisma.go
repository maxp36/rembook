// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = "my-secret-42"

func (client *Client) Book(params BookWhereUniqueInput) *BookExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BookWhereUniqueInput!", "Book"},
		"book",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

type BooksParams struct {
	Where   *BookWhereInput   `json:"where,omitempty"`
	OrderBy *BookOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Books(params *BooksParams) *BookExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BookWhereInput", "BookOrderByInput", "Book"},
		"books",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExecArray{ret}
}

type BooksConnectionParams struct {
	Where   *BookWhereInput   `json:"where,omitempty"`
	OrderBy *BookOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) BooksConnection(params *BooksConnectionParams) BookConnectionExec {
	panic("not implemented")
}

func (client *Client) Chapter(params ChapterWhereUniqueInput) *ChapterExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ChapterWhereUniqueInput!", "Chapter"},
		"chapter",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

type ChaptersParams struct {
	Where   *ChapterWhereInput   `json:"where,omitempty"`
	OrderBy *ChapterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Chapters(params *ChaptersParams) *ChapterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "Chapter"},
		"chapters",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExecArray{ret}
}

type ChaptersConnectionParams struct {
	Where   *ChapterWhereInput   `json:"where,omitempty"`
	OrderBy *ChapterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) ChaptersConnection(params *ChaptersConnectionParams) ChapterConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateBook(params BookCreateInput) *BookExec {
	ret := client.Client.Create(
		params,
		[2]string{"BookCreateInput!", "Book"},
		"createBook",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

type BookUpdateParams struct {
	Data  BookUpdateInput      `json:"data"`
	Where BookWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBook(params BookUpdateParams) *BookExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BookUpdateInput!", "BookWhereUniqueInput!", "Book"},
		"updateBook",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

type BookUpdateManyParams struct {
	Data  BookUpdateManyMutationInput `json:"data"`
	Where *BookWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBooks(params BookUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BookUpdateManyMutationInput!", "BookWhereInput"},
		"updateManyBooks")
	return &BatchPayloadExec{exec}
}

type BookUpsertParams struct {
	Where  BookWhereUniqueInput `json:"where"`
	Create BookCreateInput      `json:"create"`
	Update BookUpdateInput      `json:"update"`
}

func (client *Client) UpsertBook(params BookUpsertParams) *BookExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BookWhereUniqueInput!", "BookCreateInput!", "BookUpdateInput!", "Book"},
		"upsertBook",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

func (client *Client) DeleteBook(params BookWhereUniqueInput) *BookExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BookWhereUniqueInput!", "Book"},
		"deleteBook",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

func (client *Client) DeleteManyBooks(params *BookWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BookWhereInput", "deleteManyBooks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateChapter(params ChapterCreateInput) *ChapterExec {
	ret := client.Client.Create(
		params,
		[2]string{"ChapterCreateInput!", "Chapter"},
		"createChapter",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

type ChapterUpdateParams struct {
	Data  ChapterUpdateInput      `json:"data"`
	Where ChapterWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateChapter(params ChapterUpdateParams) *ChapterExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ChapterUpdateInput!", "ChapterWhereUniqueInput!", "Chapter"},
		"updateChapter",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

type ChapterUpdateManyParams struct {
	Data  ChapterUpdateManyMutationInput `json:"data"`
	Where *ChapterWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyChapters(params ChapterUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ChapterUpdateManyMutationInput!", "ChapterWhereInput"},
		"updateManyChapters")
	return &BatchPayloadExec{exec}
}

type ChapterUpsertParams struct {
	Where  ChapterWhereUniqueInput `json:"where"`
	Create ChapterCreateInput      `json:"create"`
	Update ChapterUpdateInput      `json:"update"`
}

func (client *Client) UpsertChapter(params ChapterUpsertParams) *ChapterExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ChapterWhereUniqueInput!", "ChapterCreateInput!", "ChapterUpdateInput!", "Chapter"},
		"upsertChapter",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

func (client *Client) DeleteChapter(params ChapterWhereUniqueInput) *ChapterExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ChapterWhereUniqueInput!", "Chapter"},
		"deleteChapter",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

func (client *Client) DeleteManyChapters(params *ChapterWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ChapterWhereInput", "deleteManyChapters")
	return &BatchPayloadExec{exec}
}

type ChapterOrderByInput string

const (
	ChapterOrderByInputIDAsc           ChapterOrderByInput = "id_ASC"
	ChapterOrderByInputIDDesc          ChapterOrderByInput = "id_DESC"
	ChapterOrderByInputCreatedAtAsc    ChapterOrderByInput = "createdAt_ASC"
	ChapterOrderByInputCreatedAtDesc   ChapterOrderByInput = "createdAt_DESC"
	ChapterOrderByInputUpdatedAtAsc    ChapterOrderByInput = "updatedAt_ASC"
	ChapterOrderByInputUpdatedAtDesc   ChapterOrderByInput = "updatedAt_DESC"
	ChapterOrderByInputNameAsc         ChapterOrderByInput = "name_ASC"
	ChapterOrderByInputNameDesc        ChapterOrderByInput = "name_DESC"
	ChapterOrderByInputDescriptionAsc  ChapterOrderByInput = "description_ASC"
	ChapterOrderByInputDescriptionDesc ChapterOrderByInput = "description_DESC"
)

type BookOrderByInput string

const (
	BookOrderByInputIDAsc           BookOrderByInput = "id_ASC"
	BookOrderByInputIDDesc          BookOrderByInput = "id_DESC"
	BookOrderByInputCreatedAtAsc    BookOrderByInput = "createdAt_ASC"
	BookOrderByInputCreatedAtDesc   BookOrderByInput = "createdAt_DESC"
	BookOrderByInputUpdatedAtAsc    BookOrderByInput = "updatedAt_ASC"
	BookOrderByInputUpdatedAtDesc   BookOrderByInput = "updatedAt_DESC"
	BookOrderByInputNameAsc         BookOrderByInput = "name_ASC"
	BookOrderByInputNameDesc        BookOrderByInput = "name_DESC"
	BookOrderByInputDescriptionAsc  BookOrderByInput = "description_ASC"
	BookOrderByInputDescriptionDesc BookOrderByInput = "description_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type ChapterUpdateManyWithoutBookInput struct {
	Create     []ChapterCreateWithoutBookInput                `json:"create,omitempty"`
	Delete     []ChapterWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []ChapterWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []ChapterWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []ChapterWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []ChapterUpdateWithWhereUniqueWithoutBookInput `json:"update,omitempty"`
	Upsert     []ChapterUpsertWithWhereUniqueWithoutBookInput `json:"upsert,omitempty"`
	DeleteMany []ChapterScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []ChapterUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type BookWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type ChapterUpdateWithoutBookDataInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ChapterWhereInput struct {
	ID                       *string             `json:"id,omitempty"`
	IDNot                    *string             `json:"id_not,omitempty"`
	IDIn                     []string            `json:"id_in,omitempty"`
	IDNotIn                  []string            `json:"id_not_in,omitempty"`
	IDLt                     *string             `json:"id_lt,omitempty"`
	IDLte                    *string             `json:"id_lte,omitempty"`
	IDGt                     *string             `json:"id_gt,omitempty"`
	IDGte                    *string             `json:"id_gte,omitempty"`
	IDContains               *string             `json:"id_contains,omitempty"`
	IDNotContains            *string             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string             `json:"createdAt,omitempty"`
	CreatedAtNot             *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string             `json:"updatedAt_gte,omitempty"`
	Name                     *string             `json:"name,omitempty"`
	NameNot                  *string             `json:"name_not,omitempty"`
	NameIn                   []string            `json:"name_in,omitempty"`
	NameNotIn                []string            `json:"name_not_in,omitempty"`
	NameLt                   *string             `json:"name_lt,omitempty"`
	NameLte                  *string             `json:"name_lte,omitempty"`
	NameGt                   *string             `json:"name_gt,omitempty"`
	NameGte                  *string             `json:"name_gte,omitempty"`
	NameContains             *string             `json:"name_contains,omitempty"`
	NameNotContains          *string             `json:"name_not_contains,omitempty"`
	NameStartsWith           *string             `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string             `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string             `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string             `json:"name_not_ends_with,omitempty"`
	Description              *string             `json:"description,omitempty"`
	DescriptionNot           *string             `json:"description_not,omitempty"`
	DescriptionIn            []string            `json:"description_in,omitempty"`
	DescriptionNotIn         []string            `json:"description_not_in,omitempty"`
	DescriptionLt            *string             `json:"description_lt,omitempty"`
	DescriptionLte           *string             `json:"description_lte,omitempty"`
	DescriptionGt            *string             `json:"description_gt,omitempty"`
	DescriptionGte           *string             `json:"description_gte,omitempty"`
	DescriptionContains      *string             `json:"description_contains,omitempty"`
	DescriptionNotContains   *string             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string             `json:"description_not_ends_with,omitempty"`
	Book                     *BookWhereInput     `json:"book,omitempty"`
	And                      []ChapterWhereInput `json:"AND,omitempty"`
	Or                       []ChapterWhereInput `json:"OR,omitempty"`
	Not                      []ChapterWhereInput `json:"NOT,omitempty"`
}

type ChapterCreateInput struct {
	ID          *string                           `json:"id,omitempty"`
	Name        string                            `json:"name"`
	Description string                            `json:"description"`
	Book        BookCreateOneWithoutChaptersInput `json:"book"`
}

type ChapterUpdateManyWithWhereNestedInput struct {
	Where ChapterScalarWhereInput    `json:"where"`
	Data  ChapterUpdateManyDataInput `json:"data"`
}

type ChapterUpsertWithWhereUniqueWithoutBookInput struct {
	Where  ChapterWhereUniqueInput           `json:"where"`
	Update ChapterUpdateWithoutBookDataInput `json:"update"`
	Create ChapterCreateWithoutBookInput     `json:"create"`
}

type BookSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *BookWhereInput              `json:"node,omitempty"`
	And                        []BookSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BookSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BookSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BookCreateInput struct {
	ID          *string                            `json:"id,omitempty"`
	Name        string                             `json:"name"`
	Description string                             `json:"description"`
	Chapters    *ChapterCreateManyWithoutBookInput `json:"chapters,omitempty"`
}

type BookUpsertWithoutChaptersInput struct {
	Update BookUpdateWithoutChaptersDataInput `json:"update"`
	Create BookCreateWithoutChaptersInput     `json:"create"`
}

type ChapterCreateManyWithoutBookInput struct {
	Create  []ChapterCreateWithoutBookInput `json:"create,omitempty"`
	Connect []ChapterWhereUniqueInput       `json:"connect,omitempty"`
}

type BookUpdateOneRequiredWithoutChaptersInput struct {
	Create  *BookCreateWithoutChaptersInput     `json:"create,omitempty"`
	Update  *BookUpdateWithoutChaptersDataInput `json:"update,omitempty"`
	Upsert  *BookUpsertWithoutChaptersInput     `json:"upsert,omitempty"`
	Connect *BookWhereUniqueInput               `json:"connect,omitempty"`
}

type ChapterCreateWithoutBookInput struct {
	ID          *string `json:"id,omitempty"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
}

type ChapterWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BookUpdateInput struct {
	Name        *string                            `json:"name,omitempty"`
	Description *string                            `json:"description,omitempty"`
	Chapters    *ChapterUpdateManyWithoutBookInput `json:"chapters,omitempty"`
}

type BookCreateOneWithoutChaptersInput struct {
	Create  *BookCreateWithoutChaptersInput `json:"create,omitempty"`
	Connect *BookWhereUniqueInput           `json:"connect,omitempty"`
}

type BookUpdateManyMutationInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ChapterUpdateManyMutationInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ChapterScalarWhereInput struct {
	ID                       *string                   `json:"id,omitempty"`
	IDNot                    *string                   `json:"id_not,omitempty"`
	IDIn                     []string                  `json:"id_in,omitempty"`
	IDNotIn                  []string                  `json:"id_not_in,omitempty"`
	IDLt                     *string                   `json:"id_lt,omitempty"`
	IDLte                    *string                   `json:"id_lte,omitempty"`
	IDGt                     *string                   `json:"id_gt,omitempty"`
	IDGte                    *string                   `json:"id_gte,omitempty"`
	IDContains               *string                   `json:"id_contains,omitempty"`
	IDNotContains            *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                   `json:"createdAt,omitempty"`
	CreatedAtNot             *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                   `json:"updatedAt_gte,omitempty"`
	Name                     *string                   `json:"name,omitempty"`
	NameNot                  *string                   `json:"name_not,omitempty"`
	NameIn                   []string                  `json:"name_in,omitempty"`
	NameNotIn                []string                  `json:"name_not_in,omitempty"`
	NameLt                   *string                   `json:"name_lt,omitempty"`
	NameLte                  *string                   `json:"name_lte,omitempty"`
	NameGt                   *string                   `json:"name_gt,omitempty"`
	NameGte                  *string                   `json:"name_gte,omitempty"`
	NameContains             *string                   `json:"name_contains,omitempty"`
	NameNotContains          *string                   `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                   `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                   `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                   `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                   `json:"name_not_ends_with,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DescriptionNot           *string                   `json:"description_not,omitempty"`
	DescriptionIn            []string                  `json:"description_in,omitempty"`
	DescriptionNotIn         []string                  `json:"description_not_in,omitempty"`
	DescriptionLt            *string                   `json:"description_lt,omitempty"`
	DescriptionLte           *string                   `json:"description_lte,omitempty"`
	DescriptionGt            *string                   `json:"description_gt,omitempty"`
	DescriptionGte           *string                   `json:"description_gte,omitempty"`
	DescriptionContains      *string                   `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                   `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                   `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                   `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                   `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                   `json:"description_not_ends_with,omitempty"`
	And                      []ChapterScalarWhereInput `json:"AND,omitempty"`
	Or                       []ChapterScalarWhereInput `json:"OR,omitempty"`
	Not                      []ChapterScalarWhereInput `json:"NOT,omitempty"`
}

type ChapterUpdateManyDataInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type BookWhereInput struct {
	ID                       *string            `json:"id,omitempty"`
	IDNot                    *string            `json:"id_not,omitempty"`
	IDIn                     []string           `json:"id_in,omitempty"`
	IDNotIn                  []string           `json:"id_not_in,omitempty"`
	IDLt                     *string            `json:"id_lt,omitempty"`
	IDLte                    *string            `json:"id_lte,omitempty"`
	IDGt                     *string            `json:"id_gt,omitempty"`
	IDGte                    *string            `json:"id_gte,omitempty"`
	IDContains               *string            `json:"id_contains,omitempty"`
	IDNotContains            *string            `json:"id_not_contains,omitempty"`
	IDStartsWith             *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string            `json:"createdAt,omitempty"`
	CreatedAtNot             *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string            `json:"updatedAt_gte,omitempty"`
	Name                     *string            `json:"name,omitempty"`
	NameNot                  *string            `json:"name_not,omitempty"`
	NameIn                   []string           `json:"name_in,omitempty"`
	NameNotIn                []string           `json:"name_not_in,omitempty"`
	NameLt                   *string            `json:"name_lt,omitempty"`
	NameLte                  *string            `json:"name_lte,omitempty"`
	NameGt                   *string            `json:"name_gt,omitempty"`
	NameGte                  *string            `json:"name_gte,omitempty"`
	NameContains             *string            `json:"name_contains,omitempty"`
	NameNotContains          *string            `json:"name_not_contains,omitempty"`
	NameStartsWith           *string            `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string            `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string            `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string            `json:"name_not_ends_with,omitempty"`
	Description              *string            `json:"description,omitempty"`
	DescriptionNot           *string            `json:"description_not,omitempty"`
	DescriptionIn            []string           `json:"description_in,omitempty"`
	DescriptionNotIn         []string           `json:"description_not_in,omitempty"`
	DescriptionLt            *string            `json:"description_lt,omitempty"`
	DescriptionLte           *string            `json:"description_lte,omitempty"`
	DescriptionGt            *string            `json:"description_gt,omitempty"`
	DescriptionGte           *string            `json:"description_gte,omitempty"`
	DescriptionContains      *string            `json:"description_contains,omitempty"`
	DescriptionNotContains   *string            `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string            `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string            `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string            `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string            `json:"description_not_ends_with,omitempty"`
	ChaptersEvery            *ChapterWhereInput `json:"chapters_every,omitempty"`
	ChaptersSome             *ChapterWhereInput `json:"chapters_some,omitempty"`
	ChaptersNone             *ChapterWhereInput `json:"chapters_none,omitempty"`
	And                      []BookWhereInput   `json:"AND,omitempty"`
	Or                       []BookWhereInput   `json:"OR,omitempty"`
	Not                      []BookWhereInput   `json:"NOT,omitempty"`
}

type ChapterUpdateWithWhereUniqueWithoutBookInput struct {
	Where ChapterWhereUniqueInput           `json:"where"`
	Data  ChapterUpdateWithoutBookDataInput `json:"data"`
}

type BookUpdateWithoutChaptersDataInput struct {
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ChapterSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ChapterWhereInput              `json:"node,omitempty"`
	And                        []ChapterSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ChapterSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ChapterSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BookCreateWithoutChaptersInput struct {
	ID          *string `json:"id,omitempty"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
}

type ChapterUpdateInput struct {
	Name        *string                                    `json:"name,omitempty"`
	Description *string                                    `json:"description,omitempty"`
	Book        *BookUpdateOneRequiredWithoutChaptersInput `json:"book,omitempty"`
}

type ChapterPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ChapterPreviousValuesExec) Exec(ctx context.Context) (*ChapterPreviousValues, error) {
	var v ChapterPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterPreviousValuesExecArray) Exec(ctx context.Context) ([]ChapterPreviousValues, error) {
	var v []ChapterPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChapterPreviousValues struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	UpdatedAt   string `json:"updatedAt"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type BookEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BookEdgeExec) Node() *BookExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Book"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

func (instance BookEdgeExec) Exec(ctx context.Context) (*BookEdge, error) {
	var v BookEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BookEdgeExecArray) Exec(ctx context.Context) ([]BookEdge, error) {
	var v []BookEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BookEdge struct {
	Cursor string `json:"cursor"`
}

type BookSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BookSubscriptionPayloadExec) Node() *BookExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Book"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

func (instance *BookSubscriptionPayloadExec) PreviousValues() *BookPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BookPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookPreviousValuesExec{ret}
}

func (instance BookSubscriptionPayloadExec) Exec(ctx context.Context) (*BookSubscriptionPayload, error) {
	var v BookSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BookSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BookSubscriptionPayload, error) {
	var v []BookSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BookSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ChapterExec struct {
	exec *prisma.Exec
}

func (instance *ChapterExec) Book() *BookExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Book"},
		"book",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &BookExec{ret}
}

func (instance ChapterExec) Exec(ctx context.Context) (*Chapter, error) {
	var v Chapter
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterExecArray) Exec(ctx context.Context) ([]Chapter, error) {
	var v []Chapter
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Chapter struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	UpdatedAt   string `json:"updatedAt"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type ChapterSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ChapterSubscriptionPayloadExec) Node() *ChapterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chapter"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

func (instance *ChapterSubscriptionPayloadExec) PreviousValues() *ChapterPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ChapterPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterPreviousValuesExec{ret}
}

func (instance ChapterSubscriptionPayloadExec) Exec(ctx context.Context) (*ChapterSubscriptionPayload, error) {
	var v ChapterSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ChapterSubscriptionPayload, error) {
	var v []ChapterSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChapterSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BookPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BookPreviousValuesExec) Exec(ctx context.Context) (*BookPreviousValues, error) {
	var v BookPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BookPreviousValuesExecArray) Exec(ctx context.Context) ([]BookPreviousValues, error) {
	var v []BookPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BookPreviousValues struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	UpdatedAt   string `json:"updatedAt"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type BookExec struct {
	exec *prisma.Exec
}

type ChaptersParamsExec struct {
	Where   *ChapterWhereInput
	OrderBy *ChapterOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BookExec) Chapters(params *ChaptersParamsExec) *ChapterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "Chapter"},
		"chapters",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExecArray{ret}
}

func (instance BookExec) Exec(ctx context.Context) (*Book, error) {
	var v Book
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookExecArray struct {
	exec *prisma.Exec
}

func (instance BookExecArray) Exec(ctx context.Context) ([]Book, error) {
	var v []Book
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Book struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	UpdatedAt   string `json:"updatedAt"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type BookConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BookConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BookConnectionExec) Edges() *BookEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BookEdge"},
		"edges",
		[]string{"cursor"})

	return &BookEdgeExec{ret}
}

func (instance *BookConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBook"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance BookConnectionExec) Exec(ctx context.Context) (*BookConnection, error) {
	var v BookConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BookConnectionExecArray) Exec(ctx context.Context) ([]BookConnection, error) {
	var v []BookConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BookConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type ChapterConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ChapterConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ChapterConnectionExec) Edges() *ChapterEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ChapterEdge"},
		"edges",
		[]string{"cursor"})

	return &ChapterEdgeExec{ret}
}

func (instance *ChapterConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateChapter"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ChapterConnectionExec) Exec(ctx context.Context) (*ChapterConnection, error) {
	var v ChapterConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterConnectionExecArray) Exec(ctx context.Context) ([]ChapterConnection, error) {
	var v []ChapterConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChapterConnection struct {
}

type ChapterEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ChapterEdgeExec) Node() *ChapterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chapter"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "description"})

	return &ChapterExec{ret}
}

func (instance ChapterEdgeExec) Exec(ctx context.Context) (*ChapterEdge, error) {
	var v ChapterEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterEdgeExecArray) Exec(ctx context.Context) ([]ChapterEdge, error) {
	var v []ChapterEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ChapterEdge struct {
	Cursor string `json:"cursor"`
}
